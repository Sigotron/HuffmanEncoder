import java.util.*;
import java.io.*;
import javax.swing.*;
@SuppressWarnings("unchecked")

/**
 * Allows user to choose a .txt file and constucts utilizes the Huffman Tree algorithm
 * to encode as well as decode the contents of the file
 * 
 * @author Joel Sigo
 * @version 03/06/2013
 */
public class HuffmanTree {
    // instance variables
    private Map<Character,HNode> mp;
    private HNode mainRoot;
    private Map<Character,String> lookupTable;
    private String encodedMessage;
    private String table;
    private String freqTable;
    private int totalNumChars;
    
    /**
     * constructor for a HuffmanTree object
     * @param t File that will be evaluated
     */
    public HuffmanTree(File t) throws FileNotFoundException {
        mp = new HashMap<Character,HNode>();
        totalNumChars = 0;
        Scanner fileSC = new Scanner(t);
        
        // DETERMINE FREQUENCIES FOR ALL CHARACTERS IN FILE LINE BY LINE
        while (fileSC.hasNextLine()) {
            String line = fileSC.nextLine();
            determineFrequencies(line);
        }
        
        // GENERATE FREQUENCY TABLE
        Set keys = mp.keySet();
        generateFreqTable(keys);
        
        // CREATE PRIORITY QUEUE AND BUILD HUFFMAN TREE
        PriorityQueue<HNode> q = new PriorityQueue<HNode>(mp.values());
        while(q.size() > 1) {
            HNode a = q.poll();
            HNode b = q.poll();
            HNode newHNode = new HNode(a.freq + b.freq,'\u0000',a,b);
            q.offer(newHNode);
        }
        mainRoot = q.poll();
    }
    
    /**
     * displays the huffman tree generated by contents of file with each level
     * represented by a different level of indentation
     */
    public void displayTree() {
        displayTree(mainRoot, 0);
    }
    
    /**
     * private recursive helper method for displayTree() utilizes a right-root-left
     * algorithm to visit each node and display it with proper indentation
     * @param root HNode to be evaluated
     * @param level int indicates level of indentation
     */
    private void displayTree(HNode root, int level) {
        if (root != null) {
            displayTree(root.right, level + 1);
            for (int k = 0; k < level; k++) {
                System.out.print("     ");
            }
            System.out.println(root.toString());
            displayTree(root.left, level + 1);
        }
    }
    
    /**
     * generates an "encoded message" based off of the contents of the file, creates
     * a lookup table which indicates char and code associated with that char
     * @param t File to be evaluated
     */
    public void encodeTree(File t) throws FileNotFoundException {
        lookupTable = new HashMap<Character,String>();
        table = "";
        encodedMessage = "";
        encodeTree(mainRoot,"");
        Scanner fileSC = new Scanner(t);
        while (fileSC.hasNextLine()) { // encode from file one line at a time
            String line = fileSC.nextLine() + "\n";
            for (int i = 0; i < line.length(); i++) {
                encodedMessage += lookupTable.get(line.charAt(i));
            }
        }
        System.out.println(encodedMessage);
    }
    
    /**
     * private recursive helper method traverses tree while saving the path as a string
     * with 0 representing a pass to the left HNode and 1 representing a pass to the 
     * right HNode. When a leaf HNode is reached that code is saved into the HNode
     * @param root HNode to be evaluated
     * @param s String code
     */
    private void encodeTree(HNode root, String s) {
        if (root == null) {
            return;
        } else if (root.left == null && root.right == null) { // then its a leaf node
            root.code = s; // assign the code stored in s to instance variable code in HNode
            lookupTable.put(root.c,root.code);
            if (root.c != '\n') table += "'" + root.c + "' >>>> " + root.code + "\n";
            else  table += "'\\n' >>>> " + root.code + "\n";
        } else { // iterate and update s appropriatly
            encodeTree(root.left, s + "0"); // go left and add 0 to s
            encodeTree(root.right, s + "1");// go right and add 1 to s
        }
    }
    
    /**
     * decodes the encoded message and displays the decoded message
     */
    public void decodeMessage() {
        HNode pointer = mainRoot;
        for (int i = 0; i < encodedMessage.length(); i++) {
            if (encodedMessage.charAt(i) == '0' && pointer.c == '\u0000') {
                pointer = pointer.left;
            } else if (encodedMessage.charAt(i) == '1' && pointer.c == '\u0000') {
                pointer = pointer.right;
            } else {
                System.out.print(pointer.c); // print current character
                pointer = mainRoot;
                i--;
            }
        }
        try { System.out.print(pointer.c); // last character
        } catch (NullPointerException e) {} // takes care of cases where file is empty
    }
    
    /**
     * displays the lookup table
     */
    private void displayLookupTable() {
        System.out.println(table);
    }
    
    /**
     * iterates through String that is passed in and stores information into a HashMap, the "key"
     * is represented by a Character and the Value is represented by an HNode. Determines the
     * frequency for which each char in the string occurs and stores it into the appropriate
     * HNode or "value"
     * @param s String to be evaluated
     */
    public void determineFrequencies(String s) {
        totalNumChars += s.length();
        for (int i = 0; i < s.length(); i++) { // iterate through characters
            if (!(mp.containsKey(s.charAt(i)))) { // if char doesn't exist create new
                mp.put(s.charAt(i),new HNode(1,s.charAt(i), null, null));
            } else { // if does exist update frequency
                HNode q = mp.get(s.charAt(i));
                mp.put(s.charAt(i),new HNode(q.freq + 1, s.charAt(i), null, null));
            }
        }
        if (!(mp.containsKey('\n'))) {  // add a \n at the end of each line
                mp.put('\n',new HNode(1,'\n', null, null));
            } else {
                HNode nl = mp.get('\n');
                mp.put('\n',new HNode(nl.freq + 1, '\n', null, null));
           }
    }
    
    /**
     * displays the average number of bits per symbol used in the encoded file
     */
    public void displayAverage() {
        System.out.println((double)encodedMessage.length() / (double)totalNumChars);
    }
    
    /**
     * displays the frequency table
     */
    public void displayFreqTable() {
        System.out.print(freqTable);
    }
    
     /**
     * generates a string version frequency table
     * @param h keyset from mp
     */
    private void generateFreqTable(Set h) {
        freqTable = "";
        Iterator<Character> it = h.iterator();
        while(it.hasNext()) {
            char k = it.next();
                if (k == '\n') freqTable += "'\\n' >>>> " + mp.get(k).freq + "\n";
                else freqTable += "'" + k + "' >>>> " + mp.get(k).freq + "\n";
        }
    }
    
    public static void main(String[] args) throws FileNotFoundException {
        // ALLOW USER TO CHOOSE FILE
        JFileChooser ch = new JFileChooser();
        ch.showOpenDialog(null);
        File f = ch.getSelectedFile();
        
        // DISPLAY ORIGINAL MESSAGE
        Scanner fileSC = new Scanner(f);
        System.out.println("********************ORIGINAL MESSAGE********************\n");
        while (fileSC.hasNextLine()) {
            String line = fileSC.nextLine();
            System.out.println(line);
        }
        System.out.println();
        
        // CREATE AND DISPLAY HUFFMAN TREE
        System.out.println("******************HUFFMAN TREE DISPLAY******************\n");
        HuffmanTree tree = new HuffmanTree(f);
        tree.displayTree();
        System.out.println();
        
        // DISPLAY FREQUENCY TABLE
        System.out.println("********************FREQUENCY TABLE*********************\n");
        tree.displayFreqTable();
        System.out.println();
        
        // ENCODE MESSAGE AND DISPLAY ENCODED MESSAGE
        System.out.println("*********************ENCODED MESSAGE********************\n");
        tree.encodeTree(f);
        System.out.println();
        
        // DISPLAY LOOKUP TABLE
        System.out.println("***********************LOOKUP TABLE*********************\n");
        tree.displayLookupTable();
        
        // DECODE ENCODED MESSAGE AND DISPLAY DECODED MESSAGE
        System.out.println("*********************DECODED MESSAGE********************\n");
        tree.decodeMessage();
        System.out.println();
        
        // DISPLAY AVERAGE NUMBER OF BITS PER SYMBOL
        System.out.println("****************AVG # OF BITS PER SYMBOL****************\n");
        tree.displayAverage();
    }
    //**********************************************************************************************
    /**
     * allows use of "nodes" for Huffman classes huffman coding implementation
     * 
     * @author Joel Sigo 
     * @version 03/04/2013
     */
    private class HNode implements Comparable<HNode>{
        
        // instance variables
        public int freq;
        public char c;
        public HNode left, right;
        public String code;
        
        /**
         * constructor for HNode object
         * @param frequency represents number of times a character is used in phrase
         * @param character represents character in phrase
         * @param leftNode represents HNode attached to left
         * @param rightNode represents HNode attached to right
         */
        HNode(int frequency, char character, HNode leftNode, HNode rightNode) {
            if (freq < 0) throw new IllegalArgumentException("freq must be greater than 0");
            freq = frequency;
            c = character;
            left = leftNode;
            right = rightNode;
            code = "";
        }
        
        /**
         * overrides compareTo method in Comparable interface. compares HNodes based on value
         * stored in freq
         * @param o HNode to be compared to this HNode
         */
        public int compareTo(HNode o) {
            if ( freq == o.freq) return 0;
            else if ( freq > o.freq) return 1;
            else return -1;
        }
        
        /**
         * returns a String representation of the HNode
         * @return String representation of HNode
         */
        public String toString() {
            if (c == '\u0000') return "HNode (" + freq + ")";
            else if (c == '\n')return "HNode (" + freq + ") Char '\\n'";
            else return "HNode (" + freq + ") Char '" + c + "'";
        }
    }
}